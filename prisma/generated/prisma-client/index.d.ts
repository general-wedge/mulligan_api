// Code generated by Prisma (prisma@1.17.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  course: (where?: CourseWhereInput) => Promise<boolean>;
  golfer: (where?: GolferWhereInput) => Promise<boolean>;
  hole: (where?: HoleWhereInput) => Promise<boolean>;
  scorecard: (where?: ScorecardWhereInput) => Promise<boolean>;
  stroke: (where?: StrokeWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export interface Fragmentable {
  $fragment<T>(fragment: string | Object): T;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;
  $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;

  /**
   * Queries
   */

  course: (where: CourseWhereUniqueInput) => Course;
  courses: (
    args?: {
      where?: CourseWhereInput;
      orderBy?: CourseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<CourseNode>>;
  coursesConnection: (
    args?: {
      where?: CourseWhereInput;
      orderBy?: CourseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CourseConnection;
  golfer: (where: GolferWhereUniqueInput) => Golfer;
  golfers: (
    args?: {
      where?: GolferWhereInput;
      orderBy?: GolferOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<GolferNode>>;
  golfersConnection: (
    args?: {
      where?: GolferWhereInput;
      orderBy?: GolferOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GolferConnection;
  hole: (where: HoleWhereUniqueInput) => Hole;
  holes: (
    args?: {
      where?: HoleWhereInput;
      orderBy?: HoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<HoleNode>>;
  holesConnection: (
    args?: {
      where?: HoleWhereInput;
      orderBy?: HoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HoleConnection;
  scorecard: (where: ScorecardWhereUniqueInput) => Scorecard;
  scorecards: (
    args?: {
      where?: ScorecardWhereInput;
      orderBy?: ScorecardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<ScorecardNode>>;
  scorecardsConnection: (
    args?: {
      where?: ScorecardWhereInput;
      orderBy?: ScorecardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScorecardConnection;
  stroke: (where: StrokeWhereUniqueInput) => Stroke;
  strokes: (
    args?: {
      where?: StrokeWhereInput;
      orderBy?: StrokeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<StrokeNode>>;
  strokesConnection: (
    args?: {
      where?: StrokeWhereInput;
      orderBy?: StrokeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StrokeConnection;
  user: (where: UserWhereUniqueInput) => User;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<UserNode>>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCourse: (data: CourseCreateInput) => Course;
  updateCourse: (
    args: { data: CourseUpdateInput; where: CourseWhereUniqueInput }
  ) => Course;
  updateManyCourses: (
    args: { data: CourseUpdateInput; where?: CourseWhereInput }
  ) => BatchPayload;
  upsertCourse: (
    args: {
      where: CourseWhereUniqueInput;
      create: CourseCreateInput;
      update: CourseUpdateInput;
    }
  ) => Course;
  deleteCourse: (where: CourseWhereUniqueInput) => Course;
  deleteManyCourses: (where?: CourseWhereInput) => BatchPayload;
  createGolfer: (data: GolferCreateInput) => Golfer;
  updateGolfer: (
    args: { data: GolferUpdateInput; where: GolferWhereUniqueInput }
  ) => Golfer;
  updateManyGolfers: (
    args: { data: GolferUpdateInput; where?: GolferWhereInput }
  ) => BatchPayload;
  upsertGolfer: (
    args: {
      where: GolferWhereUniqueInput;
      create: GolferCreateInput;
      update: GolferUpdateInput;
    }
  ) => Golfer;
  deleteGolfer: (where: GolferWhereUniqueInput) => Golfer;
  deleteManyGolfers: (where?: GolferWhereInput) => BatchPayload;
  createHole: (data: HoleCreateInput) => Hole;
  updateHole: (
    args: { data: HoleUpdateInput; where: HoleWhereUniqueInput }
  ) => Hole;
  updateManyHoles: (
    args: { data: HoleUpdateInput; where?: HoleWhereInput }
  ) => BatchPayload;
  upsertHole: (
    args: {
      where: HoleWhereUniqueInput;
      create: HoleCreateInput;
      update: HoleUpdateInput;
    }
  ) => Hole;
  deleteHole: (where: HoleWhereUniqueInput) => Hole;
  deleteManyHoles: (where?: HoleWhereInput) => BatchPayload;
  createScorecard: (data: ScorecardCreateInput) => Scorecard;
  updateScorecard: (
    args: { data: ScorecardUpdateInput; where: ScorecardWhereUniqueInput }
  ) => Scorecard;
  updateManyScorecards: (
    args: { data: ScorecardUpdateInput; where?: ScorecardWhereInput }
  ) => BatchPayload;
  upsertScorecard: (
    args: {
      where: ScorecardWhereUniqueInput;
      create: ScorecardCreateInput;
      update: ScorecardUpdateInput;
    }
  ) => Scorecard;
  deleteScorecard: (where: ScorecardWhereUniqueInput) => Scorecard;
  deleteManyScorecards: (where?: ScorecardWhereInput) => BatchPayload;
  createStroke: (data: StrokeCreateInput) => Stroke;
  updateStroke: (
    args: { data: StrokeUpdateInput; where: StrokeWhereUniqueInput }
  ) => Stroke;
  updateManyStrokes: (
    args: { data: StrokeUpdateInput; where?: StrokeWhereInput }
  ) => BatchPayload;
  upsertStroke: (
    args: {
      where: StrokeWhereUniqueInput;
      create: StrokeCreateInput;
      update: StrokeUpdateInput;
    }
  ) => Stroke;
  deleteStroke: (where: StrokeWhereUniqueInput) => Stroke;
  deleteManyStrokes: (where?: StrokeWhereInput) => BatchPayload;
  createUser: (data: UserCreateInput) => User;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => User;
  updateManyUsers: (
    args: { data: UserUpdateInput; where?: UserWhereInput }
  ) => BatchPayload;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => User;
  deleteUser: (where: UserWhereUniqueInput) => User;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  course: (
    where?: CourseSubscriptionWhereInput
  ) => CourseSubscriptionPayloadSubscription;
  golfer: (
    where?: GolferSubscriptionWhereInput
  ) => GolferSubscriptionPayloadSubscription;
  hole: (
    where?: HoleSubscriptionWhereInput
  ) => HoleSubscriptionPayloadSubscription;
  scorecard: (
    where?: ScorecardSubscriptionWhereInput
  ) => ScorecardSubscriptionPayloadSubscription;
  stroke: (
    where?: StrokeSubscriptionWhereInput
  ) => StrokeSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type HoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "holeNum_ASC"
  | "holeNum_DESC"
  | "par_ASC"
  | "par_DESC"
  | "blueTee_ASC"
  | "blueTee_DESC"
  | "whiteTee_ASC"
  | "whiteTee_DESC"
  | "redTee_ASC"
  | "redTee_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StrokeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "strokes_ASC"
  | "strokes_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CourseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "courseName_ASC"
  | "courseName_DESC"
  | "courseAddress_ASC"
  | "courseAddress_DESC"
  | "coursePhone_ASC"
  | "coursePhone_DESC"
  | "long_ASC"
  | "long_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "numberOfHoles_ASC"
  | "numberOfHoles_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GolferOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScorecardOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface StrokeCreateManyInput {
  create?: StrokeCreateInput[] | StrokeCreateInput;
  connect?: StrokeWhereUniqueInput[] | StrokeWhereUniqueInput;
}

export type CourseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HoleUpdateManyInput {
  create?: HoleCreateInput[] | HoleCreateInput;
  delete?: HoleWhereUniqueInput[] | HoleWhereUniqueInput;
  connect?: HoleWhereUniqueInput[] | HoleWhereUniqueInput;
  disconnect?: HoleWhereUniqueInput[] | HoleWhereUniqueInput;
  update?:
    | HoleUpdateWithWhereUniqueNestedInput[]
    | HoleUpdateWithWhereUniqueNestedInput;
  upsert?:
    | HoleUpsertWithWhereUniqueNestedInput[]
    | HoleUpsertWithWhereUniqueNestedInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface HoleUpdateWithWhereUniqueNestedInput {
  where: HoleWhereUniqueInput;
  data: HoleUpdateDataInput;
}

export interface StrokeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  golfer?: UserWhereInput;
  strokes?: Int;
  strokes_not?: Int;
  strokes_in?: Int[] | Int;
  strokes_not_in?: Int[] | Int;
  strokes_lt?: Int;
  strokes_lte?: Int;
  strokes_gt?: Int;
  strokes_gte?: Int;
  AND?: StrokeWhereInput[] | StrokeWhereInput;
  OR?: StrokeWhereInput[] | StrokeWhereInput;
  NOT?: StrokeWhereInput[] | StrokeWhereInput;
}

export interface GolferCreateManyInput {
  create?: GolferCreateInput[] | GolferCreateInput;
  connect?: GolferWhereUniqueInput[] | GolferWhereUniqueInput;
}

export interface StrokeUpdateWithWhereUniqueNestedInput {
  where: StrokeWhereUniqueInput;
  data: StrokeUpdateDataInput;
}

export type StrokeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HoleUpdateDataInput {
  holeNum?: Int;
  par?: Int;
  blueTee?: Int;
  whiteTee?: Int;
  redTee?: Int;
  scores?: StrokeUpdateManyInput;
}

export interface ScorecardCreateInput {
  golfers?: GolferCreateManyInput;
  course: CourseCreateOneInput;
  holes?: HoleCreateManyInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface HoleUpdateInput {
  holeNum?: Int;
  par?: Int;
  blueTee?: Int;
  whiteTee?: Int;
  redTee?: Int;
  scores?: StrokeUpdateManyInput;
}

export interface ScorecardSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScorecardWhereInput;
  AND?: ScorecardSubscriptionWhereInput[] | ScorecardSubscriptionWhereInput;
  OR?: ScorecardSubscriptionWhereInput[] | ScorecardSubscriptionWhereInput;
  NOT?: ScorecardSubscriptionWhereInput[] | ScorecardSubscriptionWhereInput;
}

export interface GolferUpdateInput {
  firstName?: String;
  lastName?: String;
}

export interface GolferSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GolferWhereInput;
  AND?: GolferSubscriptionWhereInput[] | GolferSubscriptionWhereInput;
  OR?: GolferSubscriptionWhereInput[] | GolferSubscriptionWhereInput;
  NOT?: GolferSubscriptionWhereInput[] | GolferSubscriptionWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface CourseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CourseWhereInput;
  AND?: CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput;
  OR?: CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput;
  NOT?: CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput;
}

export interface GolferCreateInput {
  firstName: String;
  lastName: String;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
}

export interface HoleUpsertWithWhereUniqueNestedInput {
  where: HoleWhereUniqueInput;
  update: HoleUpdateDataInput;
  create: HoleCreateInput;
}

export interface CourseUpsertNestedInput {
  update: CourseUpdateDataInput;
  create: CourseCreateInput;
}

export interface StrokeUpsertWithWhereUniqueNestedInput {
  where: StrokeWhereUniqueInput;
  update: StrokeUpdateDataInput;
  create: StrokeCreateInput;
}

export type HoleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface GolferUpsertWithWhereUniqueNestedInput {
  where: GolferWhereUniqueInput;
  update: GolferUpdateDataInput;
  create: GolferCreateInput;
}

export type ScorecardWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScorecardWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  golfers_every?: GolferWhereInput;
  golfers_some?: GolferWhereInput;
  golfers_none?: GolferWhereInput;
  course?: CourseWhereInput;
  holes_every?: HoleWhereInput;
  holes_some?: HoleWhereInput;
  holes_none?: HoleWhereInput;
  AND?: ScorecardWhereInput[] | ScorecardWhereInput;
  OR?: ScorecardWhereInput[] | ScorecardWhereInput;
  NOT?: ScorecardWhereInput[] | ScorecardWhereInput;
}

export interface CourseCreateInput {
  courseName: String;
  courseAddress: String;
  coursePhone: String;
  long: Float;
  lat: Float;
  numberOfHoles: Int;
  holes?: HoleCreateManyInput;
}

export interface ScorecardUpdateInput {
  golfers?: GolferUpdateManyInput;
  course?: CourseUpdateOneRequiredInput;
  holes?: HoleUpdateManyInput;
}

export interface HoleCreateManyInput {
  create?: HoleCreateInput[] | HoleCreateInput;
  connect?: HoleWhereUniqueInput[] | HoleWhereUniqueInput;
}

export interface HoleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  holeNum?: Int;
  holeNum_not?: Int;
  holeNum_in?: Int[] | Int;
  holeNum_not_in?: Int[] | Int;
  holeNum_lt?: Int;
  holeNum_lte?: Int;
  holeNum_gt?: Int;
  holeNum_gte?: Int;
  par?: Int;
  par_not?: Int;
  par_in?: Int[] | Int;
  par_not_in?: Int[] | Int;
  par_lt?: Int;
  par_lte?: Int;
  par_gt?: Int;
  par_gte?: Int;
  blueTee?: Int;
  blueTee_not?: Int;
  blueTee_in?: Int[] | Int;
  blueTee_not_in?: Int[] | Int;
  blueTee_lt?: Int;
  blueTee_lte?: Int;
  blueTee_gt?: Int;
  blueTee_gte?: Int;
  whiteTee?: Int;
  whiteTee_not?: Int;
  whiteTee_in?: Int[] | Int;
  whiteTee_not_in?: Int[] | Int;
  whiteTee_lt?: Int;
  whiteTee_lte?: Int;
  whiteTee_gt?: Int;
  whiteTee_gte?: Int;
  redTee?: Int;
  redTee_not?: Int;
  redTee_in?: Int[] | Int;
  redTee_not_in?: Int[] | Int;
  redTee_lt?: Int;
  redTee_lte?: Int;
  redTee_gt?: Int;
  redTee_gte?: Int;
  scores_every?: StrokeWhereInput;
  scores_some?: StrokeWhereInput;
  scores_none?: StrokeWhereInput;
  AND?: HoleWhereInput[] | HoleWhereInput;
  OR?: HoleWhereInput[] | HoleWhereInput;
  NOT?: HoleWhereInput[] | HoleWhereInput;
}

export interface HoleCreateInput {
  holeNum: Int;
  par: Int;
  blueTee: Int;
  whiteTee: Int;
  redTee: Int;
  scores?: StrokeCreateManyInput;
}

export interface HoleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HoleWhereInput;
  AND?: HoleSubscriptionWhereInput[] | HoleSubscriptionWhereInput;
  OR?: HoleSubscriptionWhereInput[] | HoleSubscriptionWhereInput;
  NOT?: HoleSubscriptionWhereInput[] | HoleSubscriptionWhereInput;
}

export interface UserUpdateDataInput {
  name?: String;
  email?: String;
  password?: String;
}

export interface GolferWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  AND?: GolferWhereInput[] | GolferWhereInput;
  OR?: GolferWhereInput[] | GolferWhereInput;
  NOT?: GolferWhereInput[] | GolferWhereInput;
}

export interface StrokeCreateInput {
  golfer: UserCreateOneInput;
  strokes: Int;
}

export interface CourseUpdateDataInput {
  courseName?: String;
  courseAddress?: String;
  coursePhone?: String;
  long?: Float;
  lat?: Float;
  numberOfHoles?: Int;
  holes?: HoleUpdateManyInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface GolferUpdateDataInput {
  firstName?: String;
  lastName?: String;
}

export interface UserCreateInput {
  name: String;
  email?: String;
  password?: String;
}

export interface GolferUpdateManyInput {
  create?: GolferCreateInput[] | GolferCreateInput;
  delete?: GolferWhereUniqueInput[] | GolferWhereUniqueInput;
  connect?: GolferWhereUniqueInput[] | GolferWhereUniqueInput;
  disconnect?: GolferWhereUniqueInput[] | GolferWhereUniqueInput;
  update?:
    | GolferUpdateWithWhereUniqueNestedInput[]
    | GolferUpdateWithWhereUniqueNestedInput;
  upsert?:
    | GolferUpsertWithWhereUniqueNestedInput[]
    | GolferUpsertWithWhereUniqueNestedInput;
}

export interface CourseUpdateInput {
  courseName?: String;
  courseAddress?: String;
  coursePhone?: String;
  long?: Float;
  lat?: Float;
  numberOfHoles?: Int;
  holes?: HoleUpdateManyInput;
}

export interface StrokeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StrokeWhereInput;
  AND?: StrokeSubscriptionWhereInput[] | StrokeSubscriptionWhereInput;
  OR?: StrokeSubscriptionWhereInput[] | StrokeSubscriptionWhereInput;
  NOT?: StrokeSubscriptionWhereInput[] | StrokeSubscriptionWhereInput;
}

export interface StrokeUpdateManyInput {
  create?: StrokeCreateInput[] | StrokeCreateInput;
  delete?: StrokeWhereUniqueInput[] | StrokeWhereUniqueInput;
  connect?: StrokeWhereUniqueInput[] | StrokeWhereUniqueInput;
  disconnect?: StrokeWhereUniqueInput[] | StrokeWhereUniqueInput;
  update?:
    | StrokeUpdateWithWhereUniqueNestedInput[]
    | StrokeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | StrokeUpsertWithWhereUniqueNestedInput[]
    | StrokeUpsertWithWhereUniqueNestedInput;
}

export interface CourseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  courseName?: String;
  courseName_not?: String;
  courseName_in?: String[] | String;
  courseName_not_in?: String[] | String;
  courseName_lt?: String;
  courseName_lte?: String;
  courseName_gt?: String;
  courseName_gte?: String;
  courseName_contains?: String;
  courseName_not_contains?: String;
  courseName_starts_with?: String;
  courseName_not_starts_with?: String;
  courseName_ends_with?: String;
  courseName_not_ends_with?: String;
  courseAddress?: String;
  courseAddress_not?: String;
  courseAddress_in?: String[] | String;
  courseAddress_not_in?: String[] | String;
  courseAddress_lt?: String;
  courseAddress_lte?: String;
  courseAddress_gt?: String;
  courseAddress_gte?: String;
  courseAddress_contains?: String;
  courseAddress_not_contains?: String;
  courseAddress_starts_with?: String;
  courseAddress_not_starts_with?: String;
  courseAddress_ends_with?: String;
  courseAddress_not_ends_with?: String;
  coursePhone?: String;
  coursePhone_not?: String;
  coursePhone_in?: String[] | String;
  coursePhone_not_in?: String[] | String;
  coursePhone_lt?: String;
  coursePhone_lte?: String;
  coursePhone_gt?: String;
  coursePhone_gte?: String;
  coursePhone_contains?: String;
  coursePhone_not_contains?: String;
  coursePhone_starts_with?: String;
  coursePhone_not_starts_with?: String;
  coursePhone_ends_with?: String;
  coursePhone_not_ends_with?: String;
  long?: Float;
  long_not?: Float;
  long_in?: Float[] | Float;
  long_not_in?: Float[] | Float;
  long_lt?: Float;
  long_lte?: Float;
  long_gt?: Float;
  long_gte?: Float;
  lat?: Float;
  lat_not?: Float;
  lat_in?: Float[] | Float;
  lat_not_in?: Float[] | Float;
  lat_lt?: Float;
  lat_lte?: Float;
  lat_gt?: Float;
  lat_gte?: Float;
  numberOfHoles?: Int;
  numberOfHoles_not?: Int;
  numberOfHoles_in?: Int[] | Int;
  numberOfHoles_not_in?: Int[] | Int;
  numberOfHoles_lt?: Int;
  numberOfHoles_lte?: Int;
  numberOfHoles_gt?: Int;
  numberOfHoles_gte?: Int;
  holes_every?: HoleWhereInput;
  holes_some?: HoleWhereInput;
  holes_none?: HoleWhereInput;
  AND?: CourseWhereInput[] | CourseWhereInput;
  OR?: CourseWhereInput[] | CourseWhereInput;
  NOT?: CourseWhereInput[] | CourseWhereInput;
}

export interface StrokeUpdateDataInput {
  golfer?: UserUpdateOneRequiredInput;
  strokes?: Int;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export type GolferWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CourseCreateOneInput {
  create?: CourseCreateInput;
  connect?: CourseWhereUniqueInput;
}

export interface GolferUpdateWithWhereUniqueNestedInput {
  where: GolferWhereUniqueInput;
  data: GolferUpdateDataInput;
}

export interface CourseUpdateOneRequiredInput {
  create?: CourseCreateInput;
  update?: CourseUpdateDataInput;
  upsert?: CourseUpsertNestedInput;
  connect?: CourseWhereUniqueInput;
}

export interface StrokeUpdateInput {
  golfer?: UserUpdateOneRequiredInput;
  strokes?: Int;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValuesNode {
  id: ID_Output;
  name: String;
  email?: String;
  password?: String;
}

export interface UserPreviousValues
  extends Promise<UserPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface GolferEdgeNode {
  cursor: String;
}

export interface GolferEdge extends Promise<GolferEdgeNode>, Fragmentable {
  node: <T = Golfer>() => T;
  cursor: () => Promise<String>;
}

export interface GolferEdgeSubscription
  extends Promise<AsyncIterator<GolferEdgeNode>>,
    Fragmentable {
  node: <T = GolferSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserNode {
  id: ID_Output;
  name: String;
  email?: String;
  password?: String;
}

export interface User extends Promise<UserNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<UserNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface GolferConnectionNode {}

export interface GolferConnection
  extends Promise<GolferConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<GolferEdgeNode>>>() => T;
  aggregate: <T = AggregateGolfer>() => T;
}

export interface GolferConnectionSubscription
  extends Promise<AsyncIterator<GolferConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<GolferEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateGolferSubscription>() => T;
}

export interface StrokeNode {
  id: ID_Output;
  strokes: Int;
}

export interface Stroke extends Promise<StrokeNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  golfer: <T = User>() => T;
  strokes: () => Promise<Int>;
}

export interface StrokeSubscription
  extends Promise<AsyncIterator<StrokeNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  golfer: <T = UserSubscription>() => T;
  strokes: () => Promise<AsyncIterator<Int>>;
}

export interface HoleNode {
  id: ID_Output;
  holeNum: Int;
  par: Int;
  blueTee: Int;
  whiteTee: Int;
  redTee: Int;
}

export interface Hole extends Promise<HoleNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  holeNum: () => Promise<Int>;
  par: () => Promise<Int>;
  blueTee: () => Promise<Int>;
  whiteTee: () => Promise<Int>;
  redTee: () => Promise<Int>;
  scores: <T = Promise<Array<StrokeNode>>>(
    args?: {
      where?: StrokeWhereInput;
      orderBy?: StrokeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface HoleSubscription
  extends Promise<AsyncIterator<HoleNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  holeNum: () => Promise<AsyncIterator<Int>>;
  par: () => Promise<AsyncIterator<Int>>;
  blueTee: () => Promise<AsyncIterator<Int>>;
  whiteTee: () => Promise<AsyncIterator<Int>>;
  redTee: () => Promise<AsyncIterator<Int>>;
  scores: <T = Promise<AsyncIterator<Array<StrokeSubscription>>>>(
    args?: {
      where?: StrokeWhereInput;
      orderBy?: StrokeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserNode {
  count: Int;
}

export interface AggregateUser
  extends Promise<AggregateUserNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUserNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdgeNode {
  cursor: String;
}

export interface UserEdge extends Promise<UserEdgeNode>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdgeNode>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnectionNode {}

export interface UserConnection
  extends Promise<UserConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<UserEdgeNode>>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<UserEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayload
  extends Promise<UserSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface GolferNode {
  id: ID_Output;
  firstName: String;
  lastName: String;
}

export interface Golfer extends Promise<GolferNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
}

export interface GolferSubscription
  extends Promise<AsyncIterator<GolferNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStrokeNode {
  count: Int;
}

export interface AggregateStroke
  extends Promise<AggregateStrokeNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStrokeSubscription
  extends Promise<AsyncIterator<AggregateStrokeNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseNode {
  id: ID_Output;
  courseName: String;
  courseAddress: String;
  coursePhone: String;
  long: Float;
  lat: Float;
  numberOfHoles: Int;
}

export interface Course extends Promise<CourseNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  courseName: () => Promise<String>;
  courseAddress: () => Promise<String>;
  coursePhone: () => Promise<String>;
  long: () => Promise<Float>;
  lat: () => Promise<Float>;
  numberOfHoles: () => Promise<Int>;
  holes: <T = Promise<Array<HoleNode>>>(
    args?: {
      where?: HoleWhereInput;
      orderBy?: HoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CourseSubscription
  extends Promise<AsyncIterator<CourseNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  courseName: () => Promise<AsyncIterator<String>>;
  courseAddress: () => Promise<AsyncIterator<String>>;
  coursePhone: () => Promise<AsyncIterator<String>>;
  long: () => Promise<AsyncIterator<Float>>;
  lat: () => Promise<AsyncIterator<Float>>;
  numberOfHoles: () => Promise<AsyncIterator<Int>>;
  holes: <T = Promise<AsyncIterator<Array<HoleSubscription>>>>(
    args?: {
      where?: HoleWhereInput;
      orderBy?: HoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StrokeConnectionNode {}

export interface StrokeConnection
  extends Promise<StrokeConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<StrokeEdgeNode>>>() => T;
  aggregate: <T = AggregateStroke>() => T;
}

export interface StrokeConnectionSubscription
  extends Promise<AsyncIterator<StrokeConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<StrokeEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateStrokeSubscription>() => T;
}

export interface CourseSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CourseSubscriptionPayload
  extends Promise<CourseSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Course>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CoursePreviousValues>() => T;
}

export interface CourseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourseSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CoursePreviousValuesSubscription>() => T;
}

export interface ScorecardEdgeNode {
  cursor: String;
}

export interface ScorecardEdge
  extends Promise<ScorecardEdgeNode>,
    Fragmentable {
  node: <T = Scorecard>() => T;
  cursor: () => Promise<String>;
}

export interface ScorecardEdgeSubscription
  extends Promise<AsyncIterator<ScorecardEdgeNode>>,
    Fragmentable {
  node: <T = ScorecardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CoursePreviousValuesNode {
  id: ID_Output;
  courseName: String;
  courseAddress: String;
  coursePhone: String;
  long: Float;
  lat: Float;
  numberOfHoles: Int;
}

export interface CoursePreviousValues
  extends Promise<CoursePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  courseName: () => Promise<String>;
  courseAddress: () => Promise<String>;
  coursePhone: () => Promise<String>;
  long: () => Promise<Float>;
  lat: () => Promise<Float>;
  numberOfHoles: () => Promise<Int>;
}

export interface CoursePreviousValuesSubscription
  extends Promise<AsyncIterator<CoursePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  courseName: () => Promise<AsyncIterator<String>>;
  courseAddress: () => Promise<AsyncIterator<String>>;
  coursePhone: () => Promise<AsyncIterator<String>>;
  long: () => Promise<AsyncIterator<Float>>;
  lat: () => Promise<AsyncIterator<Float>>;
  numberOfHoles: () => Promise<AsyncIterator<Int>>;
}

export interface StrokePreviousValuesNode {
  id: ID_Output;
  strokes: Int;
}

export interface StrokePreviousValues
  extends Promise<StrokePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  strokes: () => Promise<Int>;
}

export interface StrokePreviousValuesSubscription
  extends Promise<AsyncIterator<StrokePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  strokes: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCourseNode {
  count: Int;
}

export interface AggregateCourse
  extends Promise<AggregateCourseNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourseSubscription
  extends Promise<AsyncIterator<AggregateCourseNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateHoleNode {
  count: Int;
}

export interface AggregateHole
  extends Promise<AggregateHoleNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHoleSubscription
  extends Promise<AsyncIterator<AggregateHoleNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GolferSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface GolferSubscriptionPayload
  extends Promise<GolferSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Golfer>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GolferPreviousValues>() => T;
}

export interface GolferSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GolferSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GolferSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GolferPreviousValuesSubscription>() => T;
}

export interface HoleConnectionNode {}

export interface HoleConnection
  extends Promise<HoleConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<HoleEdgeNode>>>() => T;
  aggregate: <T = AggregateHole>() => T;
}

export interface HoleConnectionSubscription
  extends Promise<AsyncIterator<HoleConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<HoleEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateHoleSubscription>() => T;
}

export interface GolferPreviousValuesNode {
  id: ID_Output;
  firstName: String;
  lastName: String;
}

export interface GolferPreviousValues
  extends Promise<GolferPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
}

export interface GolferPreviousValuesSubscription
  extends Promise<AsyncIterator<GolferPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CourseEdgeNode {
  cursor: String;
}

export interface CourseEdge extends Promise<CourseEdgeNode>, Fragmentable {
  node: <T = Course>() => T;
  cursor: () => Promise<String>;
}

export interface CourseEdgeSubscription
  extends Promise<AsyncIterator<CourseEdgeNode>>,
    Fragmentable {
  node: <T = CourseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StrokeEdgeNode {
  cursor: String;
}

export interface StrokeEdge extends Promise<StrokeEdgeNode>, Fragmentable {
  node: <T = Stroke>() => T;
  cursor: () => Promise<String>;
}

export interface StrokeEdgeSubscription
  extends Promise<AsyncIterator<StrokeEdgeNode>>,
    Fragmentable {
  node: <T = StrokeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HoleSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HoleSubscriptionPayload
  extends Promise<HoleSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Hole>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HolePreviousValues>() => T;
}

export interface HoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HoleSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HolePreviousValuesSubscription>() => T;
}

export interface ScorecardConnectionNode {}

export interface ScorecardConnection
  extends Promise<ScorecardConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<ScorecardEdgeNode>>>() => T;
  aggregate: <T = AggregateScorecard>() => T;
}

export interface ScorecardConnectionSubscription
  extends Promise<AsyncIterator<ScorecardConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<ScorecardEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateScorecardSubscription>() => T;
}

export interface HoleEdgeNode {
  cursor: String;
}

export interface HoleEdge extends Promise<HoleEdgeNode>, Fragmentable {
  node: <T = Hole>() => T;
  cursor: () => Promise<String>;
}

export interface HoleEdgeSubscription
  extends Promise<AsyncIterator<HoleEdgeNode>>,
    Fragmentable {
  node: <T = HoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScorecardPreviousValuesNode {
  id: ID_Output;
}

export interface ScorecardPreviousValues
  extends Promise<ScorecardPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ScorecardPreviousValuesSubscription
  extends Promise<AsyncIterator<ScorecardPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ScorecardSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScorecardSubscriptionPayload
  extends Promise<ScorecardSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Scorecard>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScorecardPreviousValues>() => T;
}

export interface ScorecardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScorecardSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScorecardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScorecardPreviousValuesSubscription>() => T;
}

export interface StrokeSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface StrokeSubscriptionPayload
  extends Promise<StrokeSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Stroke>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StrokePreviousValues>() => T;
}

export interface StrokeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StrokeSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StrokeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StrokePreviousValuesSubscription>() => T;
}

export interface HolePreviousValuesNode {
  id: ID_Output;
  holeNum: Int;
  par: Int;
  blueTee: Int;
  whiteTee: Int;
  redTee: Int;
}

export interface HolePreviousValues
  extends Promise<HolePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  holeNum: () => Promise<Int>;
  par: () => Promise<Int>;
  blueTee: () => Promise<Int>;
  whiteTee: () => Promise<Int>;
  redTee: () => Promise<Int>;
}

export interface HolePreviousValuesSubscription
  extends Promise<AsyncIterator<HolePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  holeNum: () => Promise<AsyncIterator<Int>>;
  par: () => Promise<AsyncIterator<Int>>;
  blueTee: () => Promise<AsyncIterator<Int>>;
  whiteTee: () => Promise<AsyncIterator<Int>>;
  redTee: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateGolferNode {
  count: Int;
}

export interface AggregateGolfer
  extends Promise<AggregateGolferNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGolferSubscription
  extends Promise<AsyncIterator<AggregateGolferNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScorecardNode {
  id: ID_Output;
}

export interface Scorecard extends Promise<ScorecardNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  golfers: <T = Promise<Array<GolferNode>>>(
    args?: {
      where?: GolferWhereInput;
      orderBy?: GolferOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  course: <T = Course>() => T;
  holes: <T = Promise<Array<HoleNode>>>(
    args?: {
      where?: HoleWhereInput;
      orderBy?: HoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ScorecardSubscription
  extends Promise<AsyncIterator<ScorecardNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  golfers: <T = Promise<AsyncIterator<Array<GolferSubscription>>>>(
    args?: {
      where?: GolferWhereInput;
      orderBy?: GolferOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  course: <T = CourseSubscription>() => T;
  holes: <T = Promise<AsyncIterator<Array<HoleSubscription>>>>(
    args?: {
      where?: HoleWhereInput;
      orderBy?: HoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateScorecardNode {
  count: Int;
}

export interface AggregateScorecard
  extends Promise<AggregateScorecardNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScorecardSubscription
  extends Promise<AsyncIterator<AggregateScorecardNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseConnectionNode {}

export interface CourseConnection
  extends Promise<CourseConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<CourseEdgeNode>>>() => T;
  aggregate: <T = AggregateCourse>() => T;
}

export interface CourseConnectionSubscription
  extends Promise<AsyncIterator<CourseConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<CourseEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateCourseSubscription>() => T;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Type Defs
 */

export const prisma: Prisma;
